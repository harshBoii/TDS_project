var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// src/errors.ts
init_esm_shims();
import { AbortError as _AbortError } from "p-queue-compat";
var BaseError = class extends Error {
};
var InvalidInputError = class extends BaseError {
};
var InternalError = class extends BaseError {
};
var RequestError = class extends BaseError {
};
var NetworkError = class extends RequestError {
};
var HttpError = class extends RequestError {
  error;
  status_code;
  extensions;
  constructor(error) {
    super(error.message, { cause: error });
    this.error = error.error;
    this.status_code = error.status_code;
    this.extensions = error.extensions;
  }
};
var AbortError = _AbortError ? _AbortError : class AbortError2 extends Error {
};

// src/buildInfo.ts
init_esm_shims();
var version = "3.2.4";

// src/client.ts
init_esm_shims();
import fetchRetry from "fetch-retry";
import { StatusCodes } from "http-status-codes";

// src/helpers/config.ts
init_esm_shims();
import os from "os";
import path from "path";
import fs from "fs";
import YAML from "yaml";
function lookupEndpoint() {
  return process.env.GENAI_ENDPOINT || "https://bam-api.res.ibm.com";
}
function lookupApiKey() {
  if (process.env.GENAI_API_KEY) {
    return process.env.GENAI_API_KEY;
  }
  const credentialsPath = path.join(os.homedir(), ".genai", "credentials.yml");
  if (fs.existsSync(credentialsPath)) {
    try {
      const fileContent = fs.readFileSync(credentialsPath, "utf8");
      return YAML.parse(fileContent).apiKey;
    } catch (err) {
      console.warn("Failed to read credentials");
    }
  }
  return null;
}

// src/api/client.ts
init_esm_shims();
import createClient from "openapi-fetch";
function createApiClient(...params) {
  return createClient(...params);
}

// src/api/streaming-client.ts
init_esm_shims();
import {
  EventStreamContentType,
  fetchEventSource
} from "@ai-zen/node-fetch-event-source";
import { mergeHeaders } from "openapi-fetch";

// src/utils/stream.ts
init_esm_shims();
import { Readable } from "stream";
var TypedReadable = class extends Readable {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _read(size) {
  }
  addListener(event, listener) {
    return super.addListener(event, listener);
  }
  on(event, listener) {
    return super.on(event, listener);
  }
  [Symbol.asyncIterator]() {
    return super[Symbol.asyncIterator]();
  }
};

// src/helpers/common.ts
init_esm_shims();
function isTruthy(value) {
  return Boolean(value);
}
function concatUnique(...arrays) {
  const merged = arrays.filter(isTruthy).flat();
  return Array.from(new Set(merged).values());
}
function safeParseJson(value) {
  try {
    return JSON.parse(typeof value === "string" ? value : String(value));
  } catch {
    return null;
  }
}
function isNullish(value) {
  return value === null || value === void 0;
}

// src/api/streaming-client.ts
function createStreamingApiClient(clientOptions) {
  return {
    stream: function fetchSSE({
      url,
      headers,
      body,
      signal
    }) {
      const outputStream = new TypedReadable({
        autoDestroy: true,
        objectMode: true,
        signal
      });
      const onClose = () => {
        if (outputStream.readable) {
          outputStream.push(null);
        }
      };
      const delegatedController = new AbortController();
      if (signal) {
        signal.addEventListener(
          "abort",
          () => {
            delegatedController.abort();
          },
          {
            once: true
          }
        );
      }
      const onError = (e) => {
        const err = e instanceof BaseError ? e : new InternalError("Unexpected error", { cause: e });
        delegatedController.abort();
        if (outputStream.readable) {
          outputStream.emit("error", err);
          throw err;
        }
        onClose();
      };
      fetchEventSource(new URL(url, clientOptions.baseUrl).toString(), {
        method: "POST",
        body: JSON.stringify(body),
        headers: Object.fromEntries(
          mergeHeaders(clientOptions.headers, headers, {
            "Content-Type": "application/json"
          })
          // Types are incomplete, support is there in Node 18 https://developer.mozilla.org/en-US/docs/Web/API/Headers
        ),
        signal: delegatedController.signal,
        onclose: onClose,
        async onopen(response) {
          const contentType = response.headers.get("content-type") || "";
          if (response.ok && contentType === EventStreamContentType) {
            return;
          }
          const responseData = contentType.startsWith("application/json") ? await response.json().catch(() => null) : await response.text();
          onError(new HttpError(responseData));
        },
        onmessage(message) {
          if (message.event === "close") {
            onClose();
            return;
          }
          if (message.data === "") {
            return;
          }
          const result = safeParseJson(message.data);
          if (result === null) {
            onError(
              new InternalError(
                `Failed to parse message "${JSON.stringify(message)}"`
              )
            );
            return;
          }
          if (message.event === "error") {
            onError(new HttpError(result));
            return;
          }
          outputStream.push(result);
        },
        onerror: onError
      }).catch(() => {
      });
      return outputStream;
    }
  };
}

// src/services/text/TextService.ts
init_esm_shims();

// src/services/BaseService.ts
init_esm_shims();
var BaseService = class {
  constructor(_client, _streamingClient) {
    this._client = _client;
    this._streamingClient = _streamingClient;
  }
};

// src/utils/concurrency.ts
init_esm_shims();
import PQueue from "p-queue-compat";
function isConcurrencyLimitError(err) {
  return err instanceof HttpError && err.extensions?.code === "TOO_MANY_REQUESTS";
}
var ConcurrencyLimiter = class {
  constructor(limiter) {
    this.limiter = limiter;
  }
  _queue;
  _limiterPromise;
  async execute(task, options) {
    await this._initQueue();
    while (true) {
      try {
        return await this._queue.add(task, {
          ...options,
          throwOnTimeout: true
        });
      } catch (err) {
        if (isConcurrencyLimitError(err))
          continue;
        throw err;
      }
    }
  }
  async _initQueue() {
    if (this._queue)
      return;
    if (this._limiterPromise) {
      await this._limiterPromise;
      return;
    }
    this._limiterPromise = this.limiter();
    const { limit } = await this._limiterPromise;
    this._queue = new PQueue({ concurrency: limit });
  }
};

// src/utils/errors.ts
init_esm_shims();
function isAbortError(err) {
  return Boolean(
    err && err instanceof Error && (err.name === "AbortError" || err instanceof AbortError || err.code === "ABORT_ERR")
  );
}
var ServiceUnavailableErrorCodes = /* @__PURE__ */ new Set([
  "ENOTFOUND",
  "ETIMEDOUT",
  "ECONNRESET",
  "EHOSTDOWN",
  "ECONNREFUSED",
  "ENETUNREACH",
  // macOS
  "EHOSTUNREACH",
  // Linux
  "UND_ERR_CONNECT_TIMEOUT",
  "EAI_AGAIN"
]);
function isServiceError(err) {
  const code = err?.code;
  return !!code && ServiceUnavailableErrorCodes.has(code);
}
async function clientErrorWrapper(request) {
  try {
    const response = await request;
    if (response.error != void 0) {
      throw new HttpError(
        response.error
      );
    }
    return response.data;
  } catch (err) {
    if (err instanceof HttpError)
      throw err;
    if (isAbortError(err))
      throw err;
    if (isServiceError(err))
      throw new NetworkError("Unable to connect", { cause: err });
    throw new InternalError("Request failed", { cause: err });
  }
}

// src/services/text/TextGenerationService.ts
init_esm_shims();
var TextGenerationService = class extends BaseService {
  constructor(_client, _streamingClient, _limiter) {
    super(_client, _streamingClient);
    this._client = _client;
    this._streamingClient = _streamingClient;
    this._limiter = _limiter;
  }
  async create(input, opts) {
    return this._limiter.execute(
      () => clientErrorWrapper(
        this._client.POST("/v2/text/generation", {
          ...opts,
          params: { query: { version: "2024-03-19" } },
          body: input
        })
      ),
      { signal: opts?.signal }
    );
  }
  create_stream(input, opts) {
    return this._limiter.execute(
      async () => this._streamingClient.stream({
        url: "/v2/text/generation_stream?version=2024-03-19",
        body: input,
        signal: opts?.signal
      }),
      { signal: opts?.signal }
    );
  }
};

// src/services/text/TextTokenizationService.ts
init_esm_shims();
var TextTokenizationService = class extends BaseService {
  create(input, opts) {
    return clientErrorWrapper(
      this._client.POST("/v2/text/tokenization", {
        ...opts,
        params: { query: { version: "2024-01-10" } },
        body: input
      })
    );
  }
};

// src/services/text/TextEmbeddingService.ts
init_esm_shims();
var TextEmbeddingService = class extends BaseService {
  constructor(_client, _streamingClient, _limiter) {
    super(_client, _streamingClient);
    this._client = _client;
    this._streamingClient = _streamingClient;
    this._limiter = _limiter;
  }
  create(input, opts) {
    return this._limiter.execute(
      () => clientErrorWrapper(
        this._client.POST("/v2/text/embeddings", {
          ...opts,
          params: { query: { version: "2024-04-15" } },
          body: input
        })
      ),
      { signal: opts?.signal }
    );
  }
};

// src/services/text/TextChatService.ts
init_esm_shims();
var TextChatService = class extends BaseService {
  constructor(_client, _streamingClient, _limiter) {
    super(_client, _streamingClient);
    this._client = _client;
    this._streamingClient = _streamingClient;
    this._limiter = _limiter;
  }
  create(input, opts) {
    return this._limiter.execute(
      () => clientErrorWrapper(
        this._client.POST("/v2/text/chat", {
          ...opts,
          params: { query: { version: "2024-03-19" } },
          body: input
        })
      ),
      { signal: opts?.signal }
    );
  }
  create_stream(input, opts) {
    return this._limiter.execute(
      async () => this._streamingClient.stream({
        url: "/v2/text/chat_stream?version=2024-03-19",
        body: input,
        signal: opts?.signal
      }),
      { signal: opts?.signal }
    );
  }
};

// src/services/text/TextSentenceSimilarityService.ts
init_esm_shims();
var TextSentenceSimilarityService = class extends BaseService {
  constructor(_client, _streamingClient, _limiter) {
    super(_client, _streamingClient);
    this._client = _client;
    this._streamingClient = _streamingClient;
    this._limiter = _limiter;
  }
  create(input, opts) {
    return this._limiter.execute(
      () => clientErrorWrapper(
        this._client.POST("/v2/beta/text/sentence-similarity", {
          ...opts,
          params: { query: { version: "2023-11-22" } },
          body: input
        })
      ),
      { signal: opts?.signal }
    );
  }
};

// src/services/text/TextService.ts
var TextService = class extends BaseService {
  generation;
  tokenization;
  embedding;
  chat;
  experimental;
  constructor(client, streamingClient) {
    super(client, streamingClient);
    const generationLimiter = new ConcurrencyLimiter(async () => {
      const {
        result: { concurrency }
      } = await clientErrorWrapper(
        this._client.GET("/v2/text/generation/limits", {
          params: { query: { version: "2023-11-22" } }
        })
      );
      return concurrency;
    });
    const embeddingLimiter = new ConcurrencyLimiter(async () => {
      const {
        result: { concurrency }
      } = await clientErrorWrapper(
        this._client.GET("/v2/text/embeddings/limits", {
          params: { query: { version: "2023-11-22" } }
        })
      );
      return concurrency;
    });
    this.generation = new TextGenerationService(
      client,
      streamingClient,
      generationLimiter
    );
    this.tokenization = new TextTokenizationService(client, streamingClient);
    this.embedding = new TextEmbeddingService(
      client,
      streamingClient,
      embeddingLimiter
    );
    this.chat = new TextChatService(client, streamingClient, generationLimiter);
    this.experimental = {
      sentenceSimilarity: new TextSentenceSimilarityService(
        client,
        streamingClient,
        embeddingLimiter
      )
    };
  }
};

// src/services/ModelService.ts
init_esm_shims();
var ModelService = class extends BaseService {
  async list(input, opts) {
    return await clientErrorWrapper(
      this._client.GET("/v2/models", {
        ...opts,
        params: {
          query: {
            ...input,
            version: "2023-11-22"
          }
        }
      })
    );
  }
  async retrieve(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/models/{id}", {
        ...opts,
        params: {
          path: input,
          query: {
            version: "2024-01-30"
          }
        }
      })
    );
  }
};

// src/services/PromptService.ts
init_esm_shims();
var PromptService = class extends BaseService {
  async list(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/prompts", {
        ...opts,
        params: {
          query: {
            ...input,
            version: "2024-03-19"
          }
        }
      })
    );
  }
  async retrieve(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/prompts/{id}", {
        ...opts,
        params: {
          query: {
            version: "2024-03-19"
          },
          path: input
        }
      })
    );
  }
  async create(input, opts) {
    return clientErrorWrapper(
      this._client.POST("/v2/prompts", {
        ...opts,
        body: input,
        params: {
          query: {
            version: "2024-03-19"
          }
        }
      })
    );
  }
  async delete(input, opts) {
    return clientErrorWrapper(
      this._client.DELETE("/v2/prompts/{id}", {
        ...opts,
        params: {
          query: {
            version: "2023-11-22"
          },
          path: input
        }
      })
    );
  }
};

// src/services/RequestService.ts
init_esm_shims();
var RequestService = class extends BaseService {
  async list(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/requests", {
        ...opts,
        params: { query: { ...input, version: "2023-11-22" } }
      })
    );
  }
  async delete(input, opts) {
    return clientErrorWrapper(
      this._client.DELETE("/v2/requests/{id}", {
        ...opts,
        params: { path: input, query: { version: "2023-11-22" } }
      })
    );
  }
  async chat(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/requests/chat/{conversation_id}", {
        ...opts,
        params: { path: input, query: { version: "2024-03-19" } }
      })
    );
  }
};

// src/services/TuneService.ts
init_esm_shims();
var TuneService = class extends BaseService {
  async create(input, opts) {
    return clientErrorWrapper(
      this._client.POST("/v2/tunes", {
        ...opts,
        params: { query: { version: "2023-11-22" } },
        body: input
      })
    );
  }
  async read(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/tunes/{id}/content/{type}", {
        ...opts,
        params: { path: input, query: { version: "2023-12-15" } },
        parseAs: "blob"
      })
    );
  }
  async retrieve(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/tunes/{id}", {
        ...opts,
        params: { path: input, query: { version: "2023-11-22" } }
      })
    );
  }
  async delete(input, opts) {
    return clientErrorWrapper(
      this._client.DELETE("/v2/tunes/{id}", {
        ...opts,
        params: { path: input, query: { version: "2023-11-22" } }
      })
    );
  }
  async list(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/tunes", {
        ...opts,
        params: { query: { ...input, version: "2023-11-22" } }
      })
    );
  }
  async types(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/tuning_types", {
        ...opts,
        params: { query: { version: "2024-01-30" } }
      })
    );
  }
};

// src/services/UserService.ts
init_esm_shims();
var UserService = class extends BaseService {
  async create(input, opts) {
    return clientErrorWrapper(
      this._client.POST("/v2/user", {
        ...opts,
        body: input,
        params: {
          query: {
            version: "2023-11-22"
          }
        }
      })
    );
  }
  async retrieve(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/user", {
        ...opts,
        params: {
          query: {
            version: "2023-11-22"
          }
        }
      })
    );
  }
  async update(input, opts) {
    return clientErrorWrapper(
      this._client.PATCH("/v2/user", {
        ...opts,
        params: {
          query: {
            version: "2023-11-22"
          }
        },
        body: input
      })
    );
  }
  async delete(input, opts) {
    return clientErrorWrapper(
      this._client.DELETE("/v2/user", {
        ...opts,
        params: {
          query: {
            version: "2023-11-22"
          }
        }
      })
    );
  }
};

// src/services/FileService.ts
init_esm_shims();
var FileService = class extends BaseService {
  async create(input, opts) {
    return clientErrorWrapper(
      this._client.POST("/v2/files", {
        ...opts,
        body: { ...input, file: input.file.content },
        // file is supplied just to avoid typecast
        bodySerializer(body) {
          const formData = new FormData();
          formData.append("purpose", body.purpose);
          formData.append("file", input.file.content, input.file.name);
          return formData;
        },
        params: {
          query: {
            version: "2024-05-13"
          }
        }
      })
    );
  }
  async retrieve(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/files/{id}", {
        ...opts,
        params: {
          path: input,
          query: {
            version: "2024-05-13"
          }
        }
      })
    );
  }
  async read(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/files/{id}/content", {
        ...opts,
        params: {
          path: input,
          query: {
            version: "2023-11-22"
          }
        },
        parseAs: "blob"
      })
    );
  }
  async delete(input, opts) {
    return clientErrorWrapper(
      this._client.DELETE("/v2/files/{id}", {
        ...opts,
        params: {
          path: input,
          query: {
            version: "2023-11-22"
          }
        }
      })
    );
  }
  async list(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/files", {
        ...opts,
        params: {
          query: {
            ...input,
            version: "2024-05-13"
          }
        }
      })
    );
  }
};

// src/services/SystemPromptService.ts
init_esm_shims();
var SystemPromptService = class extends BaseService {
  async create(input, opts) {
    return clientErrorWrapper(
      this._client.POST("/v2/system_prompts", {
        ...opts,
        body: input,
        params: {
          query: {
            version: "2023-11-22"
          }
        }
      })
    );
  }
  async retrieve(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/system_prompts/{id}", {
        ...opts,
        params: {
          query: {
            version: "2023-11-22"
          },
          path: input
        }
      })
    );
  }
  async update(input, opts) {
    const { id, ...body } = input;
    return clientErrorWrapper(
      this._client.PUT("/v2/system_prompts/{id}", {
        ...opts,
        params: {
          query: {
            version: "2023-11-22"
          },
          path: { id }
        },
        body
      })
    );
  }
  async delete(input, opts) {
    return clientErrorWrapper(
      this._client.DELETE("/v2/system_prompts/{id}", {
        ...opts,
        params: {
          query: {
            version: "2023-11-22"
          },
          path: input
        }
      })
    );
  }
  async list(input, opts) {
    return clientErrorWrapper(
      this._client.GET("/v2/system_prompts", {
        ...opts,
        params: {
          query: {
            ...input,
            version: "2023-11-22"
          }
        }
      })
    );
  }
};

// src/client.ts
var Client = class {
  text;
  model;
  request;
  prompt;
  tune;
  user;
  file;
  systemPrompt;
  constructor(config = {}) {
    const endpoint = config.endpoint ?? lookupEndpoint();
    if (!endpoint) {
      throw new InvalidInputError("Configuration endpoint is missing!");
    }
    const apiKey = config.apiKey ?? lookupApiKey();
    if (!apiKey) {
      throw new InvalidInputError("Configuration API key is missing!");
    }
    const agent = version ? `node-sdk/${version}` : "node-sdk";
    const headers = new Headers(config.headers);
    headers.set("user-agent", agent);
    headers.set("x-request-origin", agent);
    headers.set("authorization", `Bearer ${apiKey}`);
    const _client = createApiClient({
      baseUrl: endpoint,
      headers,
      fetch: fetchRetry(fetch, {
        retryOn: [
          StatusCodes.TOO_MANY_REQUESTS,
          // Retry also when concurrency limits (due to external factors) are hit
          StatusCodes.BAD_GATEWAY,
          StatusCodes.SERVICE_UNAVAILABLE,
          StatusCodes.CONFLICT,
          StatusCodes.GATEWAY_TIMEOUT,
          StatusCodes.REQUEST_TIMEOUT,
          StatusCodes.INTERNAL_SERVER_ERROR
        ],
        retryDelay: function(attempt) {
          return Math.pow(2, attempt) * 1e3;
        }
      })
    });
    const _streamingClient = createStreamingApiClient({
      baseUrl: endpoint,
      headers
    });
    this.text = new TextService(_client, _streamingClient);
    this.model = new ModelService(_client, _streamingClient);
    this.request = new RequestService(_client, _streamingClient);
    this.prompt = new PromptService(_client, _streamingClient);
    this.tune = new TuneService(_client, _streamingClient);
    this.user = new UserService(_client, _streamingClient);
    this.file = new FileService(_client, _streamingClient);
    this.systemPrompt = new SystemPromptService(_client, _streamingClient);
  }
};

export {
  __commonJS,
  __toESM,
  init_esm_shims,
  BaseError,
  InvalidInputError,
  InternalError,
  RequestError,
  NetworkError,
  HttpError,
  AbortError,
  version,
  concatUnique,
  isNullish,
  Client
};
